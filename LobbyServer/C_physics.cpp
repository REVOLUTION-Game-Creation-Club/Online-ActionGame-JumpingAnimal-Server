//
//
//  Generated by Agora Plastic(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : C_physics.cpp
//  @ Date : 2005-08-18
//  @ Author : 
//
//


#include "C_physics.h"

C_physics:: C_physics( float gravx, float gravy) {
	Gravity[0] = gravx;
	Gravity[1] = gravy;

	movable_first = NULL;
	fixed_first = NULL;
	movable_obj_list = NULL;
	fixed_obj_list = NULL;

	m_list_index = 0;
	f_list_index = 0;
};

// 연산이 이루어지는 부분
// impulse 구현이 아직 안됐음
void C_physics:: step(/*HDC& hdc/*, DWORD time*/) {
	C_obj* temp;// = new C_obj("test",1,"square");

	float m/*질량*/; //impulse 구현시 사용
	float vx,vy/*속도:이동하는 픽셀*/;
	int tx,ty/*계산될 좌표*/;

	int i;

	temp = movable_first;
	for(i = 0; i<m_list_index; i++){
		//get object information
		m = temp->getmass();
		temp->getvelocity(&vx, &vy);
		temp->getxy(&tx, &ty);

		//속도만큼 좌표 이동
		tx += (int)vx;
		ty -= (int)vy;	
      
		//중력값(정확히 중력은 아니지만...) 만큼 속도 변화
		vx += Gravity[0]; // Gravity[0] = 0
		vy -= Gravity[1]; // Gravity[1] = 0.3f	

		//오브젝트의 속성 변경
		temp->setxy(tx,ty);
		//temp->setvelocity(vx,vy);
		temp->impulsex(vx);
		temp->impulsey(vy);

		culision_check(temp);

		temp->step_for_movable();

		temp = temp->next;
	}

	temp = fixed_first;
	for(i = 0; i<f_list_index; i++ )
	{
		temp->step_for_fixed();
	}

	//그림 뿌리는 부분..
//	temp = draw_first;
//	for(i = 0; i<(m_list_index + f_list_index); i++)
//	{
//		temp->onDraw(hdc);
//		temp = temp->next;
//	}
};

//중력값 변화
void C_physics:: setGravity( float gravx, float gravy) {
	Gravity[0] = gravx;
	Gravity[1] = gravy;
};

//고정되지 않은 물체 등록
void C_physics:: movable_obj_include(C_obj* inobj) {
	if(m_list_index == 0){
		movable_first = inobj;		
		movable_obj_list = inobj;

		if(f_list_index == 0){
			draw_first = inobj;
			draw_obj_list = inobj;
		}
		else
		{
			draw_obj_list->next = inobj;
			draw_obj_list = draw_obj_list->next;
		}

		m_list_index++;
	}
	else if(m_list_index > 0) {
		movable_obj_list->next = inobj;
		movable_obj_list = movable_obj_list->next;
		
		draw_obj_list->next = inobj;
		draw_obj_list = draw_obj_list->next;

		m_list_index++;
	}
};

//고정된 물체 등록
void C_physics:: fixed_obj_include(C_obj* inobj) {
	if(f_list_index == 0){
		fixed_first = inobj;
		fixed_obj_list = inobj;
		
		if(m_list_index == 0){
			draw_first = inobj;
			draw_obj_list = inobj;
		}
		else
		{
			draw_obj_list->next = inobj;
			draw_obj_list = draw_obj_list->next;
		}
		

		f_list_index++;
	}
	else if(f_list_index > 0) {
		fixed_obj_list->next = inobj;
		fixed_obj_list = fixed_obj_list->next;
		
		
		draw_obj_list->next = inobj;
		draw_obj_list = draw_obj_list->next;
		

		f_list_index++;
	}
};

//서버로 부터의 패킷과 보유 패킷 비교

void C_physics:: check_next_position( C_obj* temp) {
	
};

//이벤트가 발생한 오브젝트 반환
//아직 구현 안됐음
C_obj C_physics::evented_obj() {
	C_obj temp("1",1,"1");
	return temp;
};

//리스트의 오브젝트 반환
/*
C_obj C_physics:: ReturnObj( char* name) {
	C_obj* temp;
	int i;
	temp = movable_first;
	for(i = 0; i< m_list_index; i++) {
		if(temp->getname()){
			return *temp;
		}
	}
	return *temp;// 찾지 못하면 NULL 포인터를 반환 할것이다.
};
*/

//충돌 체크
// normal vector 를 반환 해야 하는데...
BOOL C_physics:: culision_check( C_obj* culision_main) {
	C_obj* temp;
	float tvx, tvy, tvx2, tvy2;
	int i;
	

	int center_x, center_y;

	//2차로 고정된 오브젝트와의 충돌체크
	temp = fixed_first;
	//float tvx ,tvy;
	culision_main->getvelocity(&tvx, &tvy);

	for(i = 0; i<f_list_index; i++)
	{
		//충돌 여부
		if( culision_main->x < (temp->x + temp->width) && 
			(culision_main->x + culision_main->width) > temp->x )
		{
			if( culision_main->y < (temp->y + temp->height) && 
				(culision_main->y + culision_main->height) > temp->y )
			{
				
				//충돌 방향				
				//culision_main->setxy(culision_main->x, temp->y - culision_main->height);				
				//culision_main->setvelocity(tvx, 0);
				if( (culision_main->y + tvy) >= (temp->y + temp->height) ) 
				{
					//아래에서 부딧힘(밟힘)
					//culision_main->setvelocity(tvx, 0);
					//culision_main->setxy(culision_main->x, temp->y + temp->height);
					culision_main->fbefore_state = 1;
					temp->fbefore_state = 2;
					culision_main->crash_obj_fix_up(temp);
				}
				else if (	(culision_main->y + culision_main->height + tvy) <= ( temp->y) )
				{
					//위에서 부딧힘
					//culision_main->setvelocity(tvx, 0);
					//culision_main->setxy(culision_main->x, temp->y - culision_main->height);
					culision_main->fbefore_state = 2;
					temp->fbefore_state = 1;
					culision_main->crash_obj_fix_down(temp);
				}
				else if ( ( culision_main->y + tvy ) < (temp->y + temp->height ) && 
					( culision_main->y + culision_main->height + tvy ) > (temp->y ) )
				{
					//좌우 체크
					if( ( culision_main->x - tvx ) >= (temp->x + temp->width ) )
					{
						// 오른쪽
						//culision_main->setvelocity(-tvx, tvy);
						culision_main->fbefore_state = 3;
						temp->fbefore_state = 4;
						culision_main->crash_obj_fix_right(temp);
					}
					else if ( ( culision_main->x + culision_main->width - tvx ) <= (temp->x ))
					{
						//왼쪽
						//culision_main->setvelocity(-tvx, tvy);
						culision_main->fbefore_state = 4;
						temp->fbefore_state = 3;
						culision_main->crash_obj_fix_left(temp);
					}
				}
				else 
				{
					switch(culision_main->fbefore_state)
					{
					case 1:
						culision_main->crash_obj_fix_up(temp);
						break;
					case 2:
						culision_main->crash_obj_fix_down(temp);
						break;
					case 3:
						culision_main->crash_obj_fix_right(temp);
						break;
					case 4:
						culision_main->crash_obj_fix_left(temp);
						break;
					default:
						culision_main->crash_obj_fix_up(temp);
						break;
					}
				}
			}
			
		}
	
		temp = temp->next;
	}

	//1차로 움직이는 오브젝트간의 충돌체크
	temp = movable_first;

	culision_main->getvelocity(&tvx, &tvy);
	center_x = culision_main->x + (culision_main->width/2);
	center_y = culision_main->y + (culision_main->height/2);

	for(i = 0; i<m_list_index; i++)
	{
		//충돌 여부
		if( strcmp(culision_main->getname(), temp->getname()) == 0) 
		{
			temp = temp->next;
			continue;
		}

		
		if( culision_main->x < (temp->x + temp->width) && 
			(culision_main->x + culision_main->width) > temp->x ){
				if(culision_main->y < (temp->y + temp->height) && 
					(culision_main->y + culision_main->height) > temp->y){
					
						temp->getvelocity(&tvx2, &tvy2);
						//충돌 방향
						//원래는 normal vector를 반환해야 하지만 우리 게임에서는 방향 구분이 명확하게 필요하기 때문에..
						//오브젝트 간에 위,아래와 좌,우 충돌을 구분한다.
						/*방향 구분 방법...*/
						/*충돌하면 바로 전의 위치를 연산하여 방향 예측*/
						/**/
						if( (culision_main->y + tvy) > (temp->y + temp->height + tvy2) ) 
						{
							//아래에서 부딧힘(밟힘)
							//culision_main->setcolision_dir(2);
							//culision_main->setvelocity(tvx, -5);
							//temp->setvelocity(tvx2, 5);
							//temp->setcolision_dir(1);
							culision_main->mbefore_state = 1;
							temp->mbefore_state = 2;
							culision_main->crash_obj_move_up(temp);
						}
						else if (	(culision_main->y + culision_main->height + tvy) < ( temp->y + tvy2 ) )
						{
							//위에서 부딧힘
							//culision_main->setcolision_dir(1);
							//culision_main->setvelocity(tvx, 5);
							//temp->setvelocity(tvx2, -5);
							//temp->setcolision_dir(2);
							culision_main->mbefore_state = 2;
							temp->mbefore_state = 1;
							culision_main->crash_obj_move_down(temp);
						}
						else if ( ( culision_main->y + tvy ) < (temp->y + temp->height + tvy2 ) && 
							( culision_main->y + culision_main->height + tvy ) > (temp->y + tvy2) )
						{
							//좌우 체크
							if( ( culision_main->x - tvx ) >= (temp->x + temp->width - tvx2 ) )
							{
								// 오른쪽
								//culision_main->setcolision_dir(4);
								//culision_main->setvelocity(-tvx, tvy);
								culision_main->mbefore_state = 3;
								temp->mbefore_state = 4;
								culision_main->crash_obj_move_right(temp);
								
							}
							else if ( ( culision_main->x + culision_main->width - tvx ) <= (temp->x - tvx2 ))
							{
								//왼쪽
								//culision_main->setcolision_dir(3);
								//culision_main->setvelocity(-tvx, tvy);
								culision_main->mbefore_state = 4;
								temp->mbefore_state = 3;
								culision_main->crash_obj_move_left(temp);
							}
						}
						else
						{
							switch(culision_main->mbefore_state)
							{
								case 1:
									culision_main->crash_obj_move_up(temp);
									break;
								case 2:
									culision_main->crash_obj_move_down(temp);
									break;
								case 3:
									culision_main->crash_obj_move_right(temp);
									break;
								case 4:
									culision_main->crash_obj_move_left(temp);
									break;
								default:
									culision_main->crash_obj_move_up(temp);
									break;
							}
						}
						
					}
				
			}
			
			temp = temp->next;
	}


	return true;
};

void	C_physics::boom( int x, int y, int width, int height, float power )// x, y = 중심 좌표
{
	C_obj* temp;
	int i;
	float dx, dy;

	temp = movable_first;

	for( i = 0; i < m_list_index ; i++ )
	{		
		if( ( x - (width/2) ) < (temp->x + temp->width) && 
			( x + (width/2) ) > temp->x ){
			
			if( ( y - (height/2) ) < (temp->y + temp->height) && 
				( y + (height/2) ) > temp->y){

				dx = (float)((temp->x + (temp->width/2 )) - x);
				dy = (float)( y -(temp->y + (temp->height/2))  );

				temp->impulsex(power * ( dx / (abs(dx)+abs(dy)) ));
				temp->impulsey(power * ( dy / (abs(dx)+abs(dy)) ));
			}
		}
		temp = temp->next;
	}
}	
